[{"content":" This walkthrough will show the process of creating and using C++ library in Xamarin.Forms project (Only Android).\n My Environment    Syntax Description     OS Windows 10 (64bit)   IDE/Compiler VS 2022 Community   Target Android 11    Step 1 - Creating Android Native library in C++ .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}\rNote\nMake sure that Mobile development with C++ component is installed in your Visual Studio.\n\rIn Visual Studio, Create A New Dynamic Shared Library (Android) named \u0026ldquo;MyMathFuncsLib\u0026rdquo; and for simplicity rename solution to \u0026ldquo;XamarinFormsCpp\u0026rdquo;.\nDelete the auto-created files, then create 4 new files named MyMathFuncs.h, MyMathFuncs.cpp, MyMathFuncsWrapper.h, and MyMathFuncsWrapper.cpp and copy the below codes in them (Respectively).\n MyMathFuncs.h 1 2 3 4 5 6 7 8 9 10 11  namespace MathFuncs { class MyMathFuncs { public: double Add(double a, double b); double Subtract(double a, double b); double Multiply(double a, double b); double Divide(double a, double b); }; }  \n  MyMathFuncs.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  #include \u0026#34;MyMathFuncs.h\u0026#34; namespace MathFuncs { double MyMathFuncs::Add(double a, double b) { return a + b; } double MyMathFuncs::Subtract(double a, double b) { return a - b; } double MyMathFuncs::Multiply(double a, double b) { return a * b; } double MyMathFuncs::Divide(double a, double b) { return a / b; } }  \n  MyMathFuncsWrapper.h 1 2 3 4 5 6 7 8 9 10 11  #include \u0026#34;MyMathFuncs.h\u0026#34;using namespace MathFuncs; extern \u0026#34;C\u0026#34; { MyMathFuncs* CreateMyMathFuncsClass(); void DisposeMyMathFuncsClass(MyMathFuncs* ptr); double MyMathFuncsAdd(MyMathFuncs* ptr, double a, double b); double MyMathFuncsSubtract(MyMathFuncs* ptr, double a, double b); double MyMathFuncsMultiply(MyMathFuncs* ptr, double a, double b); double MyMathFuncsDivide(MyMathFuncs* ptr, double a, double b); }  \n  MyMathFuncsWrapper.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #include \u0026#34;MyMathFuncsWrapper.h\u0026#34; MyMathFuncs* CreateMyMathFuncsClass() { return new MyMathFuncs(); } void DisposeMyMathFuncsClass(MyMathFuncs* ptr) { if (ptr != nullptr) { delete ptr; ptr = nullptr; } } double MyMathFuncsAdd(MyMathFuncs* ptr, double a, double b) { return ptr-\u0026gt;Add(a, b); } double MyMathFuncsSubtract(MyMathFuncs* ptr, double a, double b) { return ptr-\u0026gt;Subtract(a, b); } double MyMathFuncsMultiply(MyMathFuncs* ptr, double a, double b) { return ptr-\u0026gt;Multiply(a, b); } double MyMathFuncsDivide(MyMathFuncs* ptr, double a, double b) { return ptr-\u0026gt;Divide(a, b); }  \n By now your project structure should look like this:\nInfo\nFor information about above codes, refer to This link\n\rNow we should configure the project. First make sure that project is in Release for ARM64 configuration, then in Project Properties -\u0026gt; Configuration -\u0026gt; General change the target API level to the maximum value that is posible for your needs.\nAnd also rename the Root Namespace of the project to MathFuncs.\nAt the end build the project (again make sure that project is in Release for ARM64 configuration!). If every thing is OK, the project should build successfully and a file named libMathFuncs.so is created in project output directory (SolutionDir\\MyMathFuncsLib\\ARM64\\Release).\nStep 2 - Creating Xamarin.Form application Right click on the solution on Solution Explorer, then select New Project from Add menu. Choose Mobile App (Xamarin.Forms), and name it XamarinApp and create the project. In the next window select Blank as app template and only select Android as platform.\nIn Solution Explorer, right click on XamarinApp.Android and select Set As Startup Project.\nTip\nTo make sure that every thing in the XamarinApp.Android project is ok, before going any further, first build and deploy the project.\n\rStep 3 - Adding the C++ library to the Xamarin Forms Project Add a new folder to the XamarinApp.Android project named lib and another new folder to the lib folder named arm64-v8a and copy the libMathFuncs.so from the privious step to this folder. Then select the libMathFuncs.so and in Properties window, set the build action to AndroidNativeLibrary. Info\nIf you are using the .so file in a Xamarin.Android library project insted of Xamarin.Android application project, replace AndroidNativeLibrary with EmbeddedNativeLibrary. For more information refer to This link\n\rStep 4 - Creating Wrapper of C++ library for C# Add a new folder to the XamarinApp.Android project named Models and then add a new class named MyMathFuncs.cs in Models folder and replace the content of MyMathFuncs.cs with bellow code:\n MyMathFuncs.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  using Microsoft.Win32.SafeHandles; using System; using System.Runtime.InteropServices; namespace XamarinApp.Droid.Models { internal class MyMathFuncsSafeHandle : SafeHandleZeroOrMinusOneIsInvalid { public MyMathFuncsSafeHandle() : base(true) { } public IntPtr Ptr =\u0026gt; this.handle; protected override bool ReleaseHandle() { MyMathFuncsWrapper.DisposeMyMathFuncs(handle); return true; } } internal static class MyMathFuncsWrapper { const string DllName = \u0026#34;libMathFuncs.so\u0026#34;; [DllImport(DllName, EntryPoint = \u0026#34;CreateMyMathFuncsClass\u0026#34;)] internal static extern MyMathFuncsSafeHandle CreateMyMathFuncs(); [DllImport(DllName, EntryPoint = \u0026#34;DisposeMyMathFuncsClass\u0026#34;)] internal static extern void DisposeMyMathFuncs(IntPtr ptr); [DllImport(DllName, EntryPoint = \u0026#34;MyMathFuncsAdd\u0026#34;)] internal static extern double Add(MyMathFuncsSafeHandle ptr, double a, double b); [DllImport(DllName, EntryPoint = \u0026#34;MyMathFuncsSubtract\u0026#34;)] internal static extern double Subtract(MyMathFuncsSafeHandle ptr, double a, double b); [DllImport(DllName, EntryPoint = \u0026#34;MyMathFuncsMultiply\u0026#34;)] internal static extern double Multiply(MyMathFuncsSafeHandle ptr, double a, double b); [DllImport(DllName, EntryPoint = \u0026#34;MyMathFuncsDivide\u0026#34;)] internal static extern double Divide(MyMathFuncsSafeHandle ptr, double a, double b); } public class MyMathFuncs : IDisposable { readonly MyMathFuncsSafeHandle handle; public MyMathFuncs() { handle = MyMathFuncsWrapper.CreateMyMathFuncs(); } protected virtual void Dispose(bool disposing) { if (handle != null \u0026amp;\u0026amp; !handle.IsInvalid) handle.Dispose(); } public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } public double Add(double a, double b) { return MyMathFuncsWrapper.Add(handle, a, b); } public double Subtract(double a, double b) { return MyMathFuncsWrapper.Subtract(handle, a, b); } public double Multiply(double a, double b) { return MyMathFuncsWrapper.Multiply(handle, a, b); } public double Divide(double a, double b) { return MyMathFuncsWrapper.Divide(handle, a, b); } } }  \n Info\nFor information about above codes, refer to This link\n\rStep 5 - Using the Wrapper in Xamarin.Forms Add a new folder named Interfaces to the XamarinApp project. then add a new interface named IMathFuncs.cs to this folder.\nReplace the content of IMathFuncs.cs with this code:\n IMathFuncs.cs 1 2 3 4 5 6 7 8 9 10  namespace XamarinApp.Interfaces { public interface IMathFuncs { double Add(double a, double b); double Subtract(double a, double b); double Multiply(double a, double b); double Divide(double a, double b); } }  \n Add a new folder named DependencyService to the XamarinApp.Android project, then add a class to it named MathFuncs.cs and replace its content with:\n MyMathFuncs.cs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  using XamarinApp.Droid.DependencyService; using XamarinApp.Droid.Models; using XamarinApp.Interfaces; using Xamarin.Forms; [assembly: Dependency(typeof(MathFuncs))] namespace XamarinApp.Droid.DependencyService { public class MathFuncs : IMathFuncs { public double Add(double a, double b) { MyMathFuncs o = new MyMathFuncs(); return o.Add(a, b); } public double Subtract(double a, double b) { MyMathFuncs o = new MyMathFuncs(); return o.Subtract(a, b); } public double Multiply(double a, double b) { MyMathFuncs o = new MyMathFuncs(); return o.Multiply(a, b); } public double Divide(double a, double b) { MyMathFuncs o = new MyMathFuncs(); return o.Divide(a, b); } } }  \n Finally to call a function in Xamarin.Forms application, i.e. XamarinApp in this example:\n 1 2  // Calling \u0026#39;Add\u0026#39; function implemented in C++ library: double c = DependencyService.Get\u0026lt;IMathFuncs\u0026gt;().Add(10, 12);    Source Code Source code of this walkthrough.\n  Refrences:\n Walkthrough: Using C/C++ with Xamarin Use C/C++ libraries with Xamarin Xamarin.Android Using Native Libraries   ","date":"2022-12-20T00:00:00Z","permalink":"https://RBahrami.github.io/p/xamarin.forms-and-c-/","title":"Xamarin.Forms and C++"},{"content":" TinyUSB is an open-source cross-platform USB Host/Device stack for embedded systems, designed to be memory-safe with no dynamic allocation and thread-safe with all interrupt events being deferred and then handled in the non-ISR task function.\n Introduction The ST\u0026rsquo;s USB stack that is included in STM32CubeIDE, has lots of problems, including:\n Large footprint. All of the USB services are running on ISR Can\u0026rsquo;t correctly use it in RTOS  In this article, I\u0026rsquo;m going to show you how to use TinyUSB stack to create a USB mass storage device (MSD) using STM32.\nMy Environment    Syntax Description     OS Windows 10 (64bit)   Language C   IDE/Compiler STM32CubeIDE/GCC   Target STM32F429ZITx   STM32Cube Firmware FW_F4 V1.26.2   TinyUSB Version 0.13.0    Hardware I\u0026rsquo;m using a custom board with STM32F429ZI, but process isn\u0026rsquo;t diffrent for other chips and other supported ST MCUs. My board uses Full Speed USB connected to USB_OTG_FS of MCU, based on your hardware, you may also use High Speed or Full Speed USB connected to USB_OTG_HS of MCU.\nProject Configuration in CubeMX USB Peripheral As i mentioned before, i\u0026rsquo;m using USB_OTG_FS for usb communication, so first step is to enable this peripheral in cube mx. to do so, must set the Mode of USB_OTG_FS to Device Only and enable global interrupt of USB in NVIC Settings tab of Configuration window.\nClock Configuration After enabling USB hardware, we must configure the clock of the MCU. .notice{padding:18px;line-height:24px;margin-bottom:24px;border-radius:4px;color:#444;background:#e7f2fa}.notice p:last-child{margin-bottom:0}.notice-title{margin:-18px -18px 12px;padding:4px 18px;border-radius:4px 4px 0 0;font-weight:700;color:#fff;background:#6ab0de}.notice.warning .notice-title{background:rgba(217,83,79,.9)}.notice.warning{background:#fae2e2}.notice.info .notice-title{background:#f0b37e}.notice.info{background:#fff2db}.notice.note .notice-title{background:#6ab0de}.notice.note{background:#e7f2fA}.notice.tip .notice-title{background:rgba(92,184,92,.8)}.notice.tip{background:#e6f9e6}.icon-notice{display:inline-flex;align-self:center;margin-right:8px}.icon-notice img,.icon-notice svg{height:1em;width:1em;fill:currentColor}.icon-notice img,.icon-notice.baseline svg{top:0.125em;position:relative}\rNote\nUSB peripheral in STM32 need external clock source to work!\n\rImporting TinyUSB library into project Clone or download the TinyUSB reposetory in a folder. The library itself is in src folder in repository and example codes are in examples.\nCreate a new folder in Core folder of project structure and name it TinyUSB. Then right click on it and select Import. In the open window select File System (in General category), then click on Browse and navigate to the downloaded folder from last step and select src folder. In the Import window, select src folder, the rest of options in this window must be the same as following image and click on Finish.\nThe next step is to add the folder to include paths. To do so, right click on project (or Project menu) and select Properties. Then go to C/C++ General -\u0026gt; Paths and Symbols -\u0026gt; Includes and add \u0026ldquo;Core/TinyUSB\u0026rdquo;, then click on Apply and Close.\nThe Code Adding example files for MSD to project TinyUSB MSD example is in TinyUSB repository -\u0026gt; examples -\u0026gt; device -\u0026gt; msc_dual_lun. from src folder, import or copy msc_disk_dual.c and usb_descriptors.c files into Src folder of the project structure and tusb_config.h into Inc folder of the project structure.\nEdit example codes In msc_disk_dual.c, remove #include \u0026ldquo;bsp/board.h\u0026rdquo; to prevent causing error when compling the code. The default way to configure TinyUSB is to pass configuration symbols in compile time (in board.mk file). to make things easier i directly define the needed symbols in tusb_config.h file in project.\n//-------------------------------------------------------------------- // COMMON CONFIGURATION //-------------------------------------------------------------------- #define CFG_TUSB_MCU OPT_MCU_STM32F4 #define BOARD_DEVICE_RHPORT_SPEED OPT_MODE_FULL_SPEED #define BOARD_DEVICE_RHPORT_NUM 0 #define CFG_TUSB_RHPORT_MODE (OPT_MODE_DEVICE | OPT_MODE_FULL_SPEED) Redirecting STM32 USB interrupt to TinyUSB stack Add below code to stm32f4xx_it.c (or it\u0026rsquo;s equivalent if you are using another STM32 family).\n/* USER CODE BEGIN Includes */ #include \u0026#34;tusb.h\u0026#34;/* USER CODE END Includes */ ... /** * @brief This function handles USB On The Go FS global interrupt. */ void OTG_FS_IRQHandler(void) { /* USER CODE BEGIN OTG_FS_IRQn 0 */ tud_int_handler(BOARD_DEVICE_RHPORT_NUM); return; \t/* USER CODE END OTG_FS_IRQn 0 */ HAL_PCD_IRQHandler(\u0026amp;hpcd_USB_OTG_FS); /* USER CODE BEGIN OTG_FS_IRQn 1 */ /* USER CODE END OTG_FS_IRQn 1 */ } After doing above steps, we must first initialize TinyUSB stack by calling tusb_init() and then continuously calling tud_task() in the main loop of program (or in a task if using RTOS) to service the USB requests.\n/* USER CODE BEGIN Includes */ #include \u0026#34;tusb.h\u0026#34;/* USER CODE END Includes */ /* Infinite loop */ /* USER CODE BEGIN WHILE */ tusb_init(); while (1) { tud_task(); \t/* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ Now compile and flash the code. Info\nThe TinyUSB version that i used (0.13.0), has a code guard bug for synopsis port, that cause the multiple multiple definition of \u0026hellip; error when compling the code. for simplicity i deleted all ports in portable folder of imported TinyUSB library but the ST port from the project.\nAfter deleting the mentioned files, performe a clean build of project!\n\rNow when connecting the board to PC (via USB!), you should see to mass storage devices (This is a two LUN example):\n  Refrences:\n TinyUSB Offital website TinyUSB GitHUB repository A CDC (CDC+MSD) example using TinyUSB and STM32   ","date":"2022-02-23T00:00:00Z","permalink":"https://RBahrami.github.io/p/msd-using-tinyusb-stack-in-stm32/","title":"MSD using tinyUSB stack in STM32"}]